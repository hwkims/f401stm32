# STM32 NUCLEO-F401RE와 함께하는 임베디드 개발 여정: LED 깜빡임부터 시작하여 확장 가능성 탐색 🚀✨

안녕하세요! 👋 오늘은 STM32 NUCLEO-F401RE 보드와 함께한 제 임베디드 개발 여정을 여러분과 공유하려고 합니다. 처음에는 간단한 LED 깜빡임으로 시작했지만, 점점 하드웨어 제어의 세계를 깊이 탐험하게 되었네요! 마치 작은 씨앗이 싹을 틔우고 무럭무럭 자라나는 듯한 기분이에요! 🌱
![image](https://github.com/user-attachments/assets/56cd622c-7365-46ba-9685-fc17680c0ab3)

## 🌟 프로젝트 개요

이 프로젝트는 STM32 NUCLEO-F401RE 개발 보드에서 **레지스터를 직접 제어**하여 파란색 LED (LD2) 를 켜고 끄는 방법을 익히고, **파란색 버튼 (B1)** 을 눌러 LED 를 토글하는 기능을 구현하는 것을 목표로 합니다. 임베디드 시스템 개발의 기초를 다지고,  하드웨어와 소프트웨어의 상호작용을 이해하는 데 중점을 두었습니다.

## 🧱 하드웨어 구성

* **STM32 NUCLEO-F401RE 개발 보드:**  ARM Cortex-M4 코어를 기반으로 하는 강력한 마이크로컨트롤러 개발 보드입니다.
* **파란색 LED (LD2):**  온보드 파란색 LED (PA5 핀에 연결).
* **파란색 버튼 (B1):**  온보드 파란색 사용자 버튼 (PC13 핀에 연결).

## ⚙️ 코드 구조

핵심 코드는 `main.c` 파일에 작성되었으며,  다음과 같은 단계로 구성됩니다.

1. **레지스터 주소 정의 (매크로 상수):**

   *   GPIOA, GPIOC, RCC 등 주변 장치들의 기준 주소 및 필요한 레지스터 offset 주소를 매크로 상수(`#define`) 로 정의하여 코드 가독성을 높입니다.
   *   LED (LD2) 및 버튼 (B1) 에 해당하는 핀 번호도 매크로 상수로 정의하여 코드 유지보수를 용이하게 합니다.

2.  **GPIO 레지스터 초기화 (Init) 부분:**

    * **GPIOA 클럭 활성화:** GPIOA 를 사용하기 위해 RCC (Reset and Clock Control) 레지스터를 설정하여 GPIOA 에 클럭을 공급합니다.
    * **PA5 핀 (LD2) 출력 모드 설정:**  GPIOA_MODER 레지스터를 설정하여 PA5 핀을 "General purpose output" 모드로 설정합니다.
    * **GPIOC 클럭 활성화:** GPIOC 를 사용하기 위해 RCC 레지스터를 설정하여 GPIOC 에 클럭을 공급합니다.
    * **PC13 핀 (B1) 입력 모드 설정:**  GPIOC 입력 모드 설정 및 풀업 저항 활성화 코드를 작성합니다. 이 부분에서는 HAL 라이브러리 구조체와 초기화 함수를 일부 사용했습니다 (내장 풀업 저항 사용을 위해서).

3.  **while(1) 루프 (핵심 동작):**

    *   **버튼 입력 감지:**  GPIOC 입력 데이터 레지스터 (`GPIOC_IDR`) 를 읽어서 B1 버튼이 눌렸는지 확인합니다.
    *  **채터링 방지:**  딜레이 함수 (`delay_ms()`) 를 이용하여 버튼 채터링을 제거합니다. 채터링은 기계식 스위치에서 발생하는 일시적인 접점 불안정 현상입니다.
    *  **LED 상태 토글:**  GPIOA 출력 데이터 레지스터 (`GPIOA_ODR`) 를 읽어서,  현재 LED 상태를 확인하고,  비트 XOR 연산 (`^=`) 을 사용하여 LED 상태를 반전시킵니다 (켜짐 <-> 꺼짐).  즉, 한 번 누를 때마다 켜짐/꺼짐 상태가 바뀝니다.
    * **버튼 뗄 때까지 대기:**  `while` 루프를 사용하여 버튼에서 손을 뗄 때까지 기다립니다.  채터링 방지 효과를 더 높이는 데 도움이 됩니다.

4.  **딜레이 함수 (`delay_ms()`):**
    * HAL 라이브러리의 `HAL_Delay()` 대신 직접 구현한 간단한 딜레이 함수입니다.  while 루프를 돌면서 시간을 지연시킵니다.

## 🔑 핵심 개념

* **기준 주소 (Base Address):**  각 주변 장치 블록 (GPIOA, USART2 등) 이 메모리 맵에서 차지하는 시작 주소.
* **Offset 주소:**  각 레지스터가 해당 주변 장치 블록 기준 주소에서 얼마나 떨어져 있는지 나타내는 주소 값.
* **레지스터 직접 접근:**  특정 주소에 값을 읽고 쓰면서 하드웨어를 직접 제어하는 방식.
* **비트 연산:**
    * **OR (`|`):**  두 비트 중 하나라도 1이면 1 (LED 켜기).
    * **AND (`&`):**  두 비트가 모두 1이면 1 (특정 비트 확인).
    * **NOT (`~`):**  비트 값 반전 (0 -> 1, 1 -> 0)
    * **XOR (`^`):** 두 비트가 다르면 1, 같으면 0 (LED 토글).
    * **Shift (`<<`, `>>`):** 비트 이동 (마스크 생성).
* **채터링 (Bouncing):**  버튼을 누르거나 뗄 때 접점 떨림 현상 (오작동 유발)
* **Debouncing:** 채터링을 제거하는 방법 (소프트웨어 딜레이, 상태 머신 등)

## ➕ 확장 기능 (다음 단계):

NUCLEO-F401RE 보드는 다양한 확장이 가능합니다. 아래와 같은 프로젝트들을 더 진행해 볼 수 있습니다.

* **USB HID 키보드:**  보드를 USB 키보드로 인식시켜서 특정 키 입력이나 매크로 기능을 구현.
* **시리얼 통신 (UART):** PC 와 시리얼 통신을 통해 데이터를 주고받는 기능 구현.
* **외부 센서 연동:** 온도, 습도, 조도, 압력 센서 등을 연결하여 외부 환경 데이터 읽어오기.
* **외부 모터 제어:**  DC 모터, 서보 모터, 스테퍼 모터 등을 연결하여 모터 제어.
* **LCD/OLED 디스플레이:**  문자, 숫자, 그래프 등 디스플레이 출력.
* **무선 통신 모듈 (WiFi, Bluetooth, LoRa):** 무선 통신을 이용한 데이터 송수신.

## 👨‍💻 마치며

지금까지 NUCLEO-F401RE 보드를 가지고 LED 를 깜빡이면서 시작해서,  버튼 입력, 레지스터 직접 제어, 그리고 다양한 확장 가능성까지 살펴보았습니다. 작은 불빛 하나를 켜는 것부터 시작했지만,  이 경험을 통해 임베디드 개발의 무궁무진한 가능성을 엿볼 수 있었어요.  앞으로 더 많은 것을 배우고,  더 멋진 작품들을 만들어 갈 수 있도록 노력하겠습니다! 😊

혹시 이 글을 읽으시다가 궁금한 점이나,  추가로 알고 싶으신 내용이 있다면 언제든지 댓글로 알려주세요!
